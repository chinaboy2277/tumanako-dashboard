package com.tumanako.sensors;

/************************************************************************************
Tumanako - Electric Vehicle and Motor control software

Copyright (C) 2012 Jeremy Cole-Baker <jeremy@rhtech.co.nz>

This file is part of Tumanako Dashboard.

Tumanako is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Tumanako is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Tumanako.  If not, see <http://www.gnu.org/licenses/>.

*************************************************************************************/

import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Binder;
import android.os.Handler;
import android.os.IBinder;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;



/**********************************************************
 * Data Input Service:
 * 
 * This class creates a service which manages data generation / input / processing. 
 * The Tumanako app may get data from several sources:
 *  
 *  -A connection to the vehicle (USB, Bluetooth, etc)
 *  -Built in sensors in the Android device (GPS, accelerometer, etc)
 *  -Other sources (website, external GPS, etc). 
 * 
 * We want to seperate the data input and processing from the UI drawing. 
 * This allows us to 'connect' to the data sources when our app is in the 
 * foreground, and keep our connections alive during configuration changes
 * such as screen rotates, changing pages, etc. 
 * 
 * When all our app activities are closed or in the background, our data 
 * connections should be suspended so that they don't waste CPU time and
 * battery power if the user is doing something else with their Android
 * device. 
 * 
 * To achieve the above, this class implements a Service. We'll start it
 * explicitly with 'startService' so that it's not closed when any 
 * particular UI Activity is closed / redrawn. We'll use an internal 
 * 'Watchdog' mechanism that will automatically stop the service if no 
 * UI activity interracts with it for more than a certain time length. 
 * 
 *  Note: The service model could be extended in the future to allow 
 *  it to keep running while the UI was in the background, for example
 *  if we wanted to log data to a file even when the user was doing 
 *  something else. 
 *  
 * @author Jeremy
 *
 ************************************************************/



public class DataService  extends Service
  {

  /****************************************************
   * Data Sources we'd like to use: 
   ****************************************************/
  public NmeaGPS     deviceGPS;                               
  public VehicleData vehicleData;

  private final Handler updateTimer = new Handler();  // Internal update timer: creates a 'refresh' interval on which we will do things.
  private int watchdogCounter = 0;                    // Used to track sensor events; must be explicitly reset periodically by client applications. 
                                                      // If it overflows, service will stop itself.

  private static final int UPDATE_INTERVAL = 2000;    // Carry out update every n mSeconds.
  private static final int WATCHDOG_OVERFLOW = 5;     // Watchdog will cause service to stop if not reset for n x UPDATE_INTERVAL 
 
  public static final String DATA_SERVICE_KEEPALIVE = "com.tumanako.sensors.serviceKeepAlive";  // An Intent with this Action is generated by the UI to tell the service that it's still needed.
  
  // Create a Binder object to receive interactions from client.
  // LocalBinder is a private internal class defined below. 
  private final IBinder mBinder = (IBinder) new LocalBinder();


  // ---------------DEMO MODE CODE -------------------------------
  private boolean isDemo = false;
  public static final String DATA_SERVICE_DEMO = "com.tumanako.sensors.serviceDemo";
  public static final String SERVICE_DEMO_SETTO = "com.tumanako.sensors.serviceDemoSetTo";
  // ---------------DEMO MODE CODE -------------------------------
  
  
  /****** Constructor ***********************/
  public DataService()
    {
    super();
    Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> Constructor; ");
    }
  
  
  /*****************************************
   * Keep Alive Method: 
   * UI pages should connect to the service 
   * and call this occasionally to prevent 
   * the service timing out. 
   *****************************************/
  public void keepAlive()
    {     
    watchdogCounter = 0;   // Reset the watchdog timer.     
    }

  
  
  // ---------------DEMO MODE CODE -------------------------------
  public void setDemo(boolean thisIsDemo)
    {
    // Set the 'Demo' mode flag: 
    isDemo = thisIsDemo;
    deviceGPS.NMEAData.setDemo(thisIsDemo);
    vehicleData.setDemo(thisIsDemo);
    }
  // ---------------DEMO MODE CODE -------------------------------
  
  
  
  /*************************************************************
   * Sensor Start and Stop methods: 
   ************************************************************/
  private void sensorStart()
    {
    deviceGPS.resume();
    vehicleData.resume();
    }
  
  private void sensorStop()
    {
    deviceGPS.suspend();
    vehicleData.suspend();
    }
  
  
  
  /**********************************************************************************************
   * Update Timer Runnable:  
   **********************************************************************************************/
  private Runnable updateTimerTask = new Runnable() 
      {
      public void run()  
        {
        watchdogCounter++;
        // Check Watchdog Counter for Overflow: 
        if (watchdogCounter > WATCHDOG_OVERFLOW)
          {
          // Watchdog Expired!
          sensorStop();         // Stop the sensors.
          stopSelf();           // Stop the service!
          }
        else
          {     
          // Restart the update timer: 
          updateStart();
          }
        } 
      };      
    /**********************************************************************************************
     * Start and Stop update timer:  
     **********************************************************************************************/
    private void updateStart()
      {
      updateTimer.removeCallbacks(updateTimerTask);
      updateTimer.postDelayed(updateTimerTask, UPDATE_INTERVAL);    
      }
    /**********************************************************************************************/    
    private void updateStop()
      {
      updateTimer.removeCallbacks(updateTimerTask);  
      }
    /**********************************************************************************************/


    

    
    
    /*******************************************************************************
     * Declare a Broadcast Receiver to catch intents sent from the UI:
     * Called whenever an intent is sent with action DATA_SERVICE_KEEPALIVE
     * (actual constant value defined above)
     *******************************************************************************/
    private BroadcastReceiver messageReceiver = new BroadcastReceiver() 
      {
      @Override
      public void onReceive(Context context, Intent intent)  
        {
        keepAlive();
        
        // ---------------DEMO MODE CODE -------------------------------
        if (intent.getAction() == DATA_SERVICE_DEMO)
          {
          // An intent to turn demo mode on or off.
          boolean demoOn = intent.getBooleanExtra(SERVICE_DEMO_SETTO,false);
          if (demoOn) setDemo(true);
          else        setDemo(false);
          }
        // ---------------DEMO MODE CODE -------------------------------        
        
        }
      };  // [messageReceiver Inner Class]
    
    
    
    
    
     
    
    /*************************************************
     * Private BINDER class: Used to return a binder 
     * so clients can interract with us!
     * The IBinder interface specifies that we must 
     * impliment one method called 'getService()'
     * which returns a reference to our service:
     * 
     * @author Jeremy Cole-Baker / Riverhead Technology
     *************************************************/
    public class LocalBinder extends Binder 
      {   public DataService getService()  {  return DataService.this;  }   };

    

    
    
    /*********************************************************************
     * Service Methods: 
     * We override the following Service methods to respond to various 
     * sensor events. 
     ********************************************************************/
    
    
    @Override
    public void onCreate() 
      {
      // Sensor Service CREATED:
      Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> onCreate(); ");      
      // Add some sensors: 
      deviceGPS = new NmeaGPS(this);
      vehicleData = new VehicleData(this);
      }

    
    
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) 
      {
      // Start Command: Someone requested that the serice be started: 
      super.onStartCommand(intent, flags, startId);
      Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> Received start id " + startId + ": " + intent);
      updateStart();
      sensorStart();         // Start the Sensors (if not already started!)
      // Register to receive messages via Intents:
      LocalBroadcastManager.getInstance(this).registerReceiver(messageReceiver,  new IntentFilter(DATA_SERVICE_KEEPALIVE));
        // We are registering an observer (messageReceiver) to receive Intents
        // with actions named DATA_SERVICE_KEEPALIVE. Whenever we receive these, reset the watchdog to keep the service running.
      
   // ---------------DEMO MODE CODE -------------------------------
      LocalBroadcastManager.getInstance(this).registerReceiver(messageReceiver,  new IntentFilter(DATA_SERVICE_DEMO));
   // ---------------DEMO MODE CODE -------------------------------
      
      // We want this service to continue running until it is explicitly stopped, so return 'sticky':
      return START_STICKY;
      }


    
    
    
    @Override
    public IBinder onBind(Intent intent) 
      {
      Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> onBind(); " );
      updateStart();         // Start Update Timer
      sensorStart();         // Start the Sensors (if not already started!) 
      return mBinder;
      }

    

    
    @Override
    public boolean onUnbind (Intent intent)
      {
      // UNBIND: A client has unbound. Don't need to do anything.
      Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> onUnBind(); " );
      return true;
      }

    
    
    @Override
    public void onRebind (Intent intent)
      {
      Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> onReBind(); " );
      // REBIND: A client has reconnected to the service after disconnecting. 
      updateStart();         // Start update timer.
      sensorStart();         // Start the Sensors (if not already started!)      
      }



    @Override
    public void onDestroy() 
      {
      // Service DESTROYED:
      Log.i(com.tumanako.ui.UIActivity.APP_TAG, " DataService -> onDestroy(); " );
      // Unregister the Intent listener since the service is about to be destroyed.
      LocalBroadcastManager.getInstance(this).unregisterReceiver(messageReceiver);
      updateStop();          // Stop update timer. 
      sensorStop();          // Stop the sensors.
      deviceGPS = null;
      vehicleData = null;
      }


  
  
  }
