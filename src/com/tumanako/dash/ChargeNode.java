package com.tumanako.dash;


/************************************************************************************
 Tumanako - Electric Vehicle and Motor control software
 
 Copyright (C) 2012 Jeremy Cole-Baker <jeremy@rhtech.co.nz>

 This file is part of Tumanako Dashboard.

 Tumanako is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published
 by the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Tumanako is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with Tumanako.  If not, see <http://www.gnu.org/licenses/>.
 
*************************************************************************************/


import java.lang.ref.WeakReference;

import com.tumanako.ui.UIActivity;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;


/***********************************************************************
 * Charge Node Module: 
 *
 * A WebView control displays data supplied by the charge node (HTML). 
 * Buttons in the UI generate intents which this class catches.
 *  
 *  -Connect to Node: Look for the server and display its web page
 *   if found. NOTE: Must already have a WiFi connection to the node. 
 * 
 *  -Start Charge: Tell the node that we want some power!
 *  
 *  -Stop Charge: Tell the node that we've had enough. 
 *  
 *  While connected to the node, we will periodically poll it to 
 *  get some status information. 
 *
 * A seperate thread will be used ot handle network operations. beware
 * thread safety!
 * 
 * @author Jeremy Cole-Baker / Riverhead Technology
 *
 **********************************************************************/

public class ChargeNode implements IDashMessages
  {

  /************** Action strings to identify Intents used by this class: ******************************************************/
  public static final String CHARGE_NODE_INTENT     = "com.tumanako.dash.chargenode";             // An Intent with this Action is generated by the UI to send messages to this class.
  
  /************* Message IDs: Used to identify specific intent messages. **************************/
  public static final int CHARGE_NODE_CONNECT      = IDashMessages.CHARGE_NODE_ID +  2;      // } Send by the UI: tells us to connect to server. 
  public static final int CHARGE_NODE_CHARGESTART  = IDashMessages.CHARGE_NODE_ID +  3;      // }                 tells us to start charging. 
  public static final int CHARGE_NODE_CHARGESTOP   = IDashMessages.CHARGE_NODE_ID +  4;      // }                 tells us to stop charging.
  public static final int CHARGE_NODE_HTMLRECEIVED = IDashMessages.CHARGE_NODE_ID +  5;      // } Sent by the CommThread class: HTML has arrived from the server. 
  public static final int CHARGE_NODE_XMLRECEIVED  = IDashMessages.CHARGE_NODE_ID +  6;      // }                               XML has arrived from the server.
  public static final int CHARGE_NODE_SERVERERROR  = IDashMessages.CHARGE_NODE_ID + 99;      // }                               Error connecting to server. 
  /************* Charger Data Tags: **************************************/
  public static final String CHARGE_STATUS  = "CHGSTAT"; //  
  public static final String CHARGE_CURRENT = "CHGCUR";  // These are used as keys when sending data to the UI as a bundle. 
  public static final String CHARGE_AH      = "CHGAH";   //
  /************ Status Constants: **************************************/
  public static final int STATUS_DISCONNECTED = 0;
  public static final int STATUS_CONNECTING   = 1;
  public static final int STATUS_CONNECTED    = 2;
  public static final int STATUS_CHARGING     = 3;
  
  public static final String CHARGE_NODE_DEFAULT_HTML = 
              "<html><body>" +
                "<p><b>Charge Station</b></p>" +
                "<ol><li>Use the Wi-Fi settings on your device to connect to the Wi-Fi hotspot provided by the charging station.</li>" +
                    "<li>Press 'Connect' to connect to the charge station and check prices!</li></ol>" +
               "</body></html>";
  
  
  public static final String CHARGE_NODE_CONNECT_HTML = 
      "<html><body>" +
        "<p><b>Charge Station</b></p>" +
        "<p>Connecting...</p>" +
       "</body></html>";  
  
  private static final String CHARGE_URL = "http://www.rhtech.co.nz/chargenode/index.php";   // This is the URL we'll connect for communications with the charger.  
  private static final String PING_URL = "http://www.rhtech.co.nz/chargenode/update.php";   // This is the URL we'll connect for communications with the charger.
  
  private DashMessages dashMessages;
  private Context nodeContext;

  private int status = STATUS_DISCONNECTED;
  private int watchdogCounter = 0;            // This counter will increment whenever we are waiting for something to happen; allows us to detect a timeout. 
  
  
  private static final int READ_EVERY = 5000;              // Reconnect to the server every n mseconds.
  private static final int WATCHDOG_OVERFLOW = 3;          // Max watchdog counter value - generate error or retry after this value is reached. 
  
  private final Handler updateTimer = new Handler();       // Message handler for update timer (sends data periodically)
  
  private final WeakReference<Context> weakContext; 
  
  private String serverPage = "";
  
  private Bundle cookieData = new Bundle();
  
  /****** Constructor ***********************/
  public ChargeNode(Context context)
    {
    nodeContext = context;
    dashMessages = new DashMessages(context,this,CHARGE_NODE_INTENT);
    weakContext = new WeakReference<Context>(nodeContext);    
    status = STATUS_DISCONNECTED;
    updateTimer.postDelayed(updateTimerTask, READ_EVERY);  // ...Callback in n milliseconds!    
    }
  
  
  
  
  
  /*********** Intent Procerssor: ***********************************************************************************************************/ 
  public void messageReceived(String action, int message, Float floatData, String stringData, Bundle data )
    {
    // --DEBUG!--Log.i(com.tumanako.ui.UIActivity.APP_TAG, String.format( " ChargeNode -> Msg Rec: %d", message) );    


    // Check to see if any cookie data have been received (e.g. from a web server): 
    if ( (data != null) && (data.containsKey("Cookies")) )
      {
      Bundle tempCookies = data.getBundle("Cookies");
      if (!tempCookies.isEmpty()) cookieData = new Bundle(tempCookies); 
      }

    ChargerHTTPConn commThread;
    
    switch (message)
      {
      // CommThread(WeakReference<Context> weakContext, String thisConnectTo, boolean thisExpectXML, Bundle thisPostData)       
      
      /************** Messages from the UI: ****************************/
      case CHARGE_NODE_CONNECT:
        // Start a new network thread to connect to the server:
        dashMessages.sendData( UIActivity.UI_INTENT_IN, IDashMessages.CHARGE_NODE_ID, null,CHARGE_NODE_CONNECT_HTML,getChargeData(STATUS_DISCONNECTED,0f,0f) );
        status = STATUS_CONNECTING;
        commThread = new ChargerHTTPConn(weakContext,CHARGE_NODE_INTENT,CHARGE_NODE_HTMLRECEIVED,CHARGE_NODE_XMLRECEIVED,CHARGE_NODE_SERVERERROR,CHARGE_URL,false,null,cookieData);        // Start the Comm thread, and give it the URL of the server. 
        commThread.run();
        updateTimerReset();
        break;
        

      case CHARGE_NODE_CHARGESTART:
        commThread = new ChargerHTTPConn(weakContext,CHARGE_NODE_INTENT,CHARGE_NODE_HTMLRECEIVED,CHARGE_NODE_XMLRECEIVED,CHARGE_NODE_SERVERERROR,PING_URL + "?action=start", true, null,cookieData);     
        commThread.run();
        updateTimerReset();
        break;
      
      case CHARGE_NODE_CHARGESTOP:
        commThread = new ChargerHTTPConn(weakContext,CHARGE_NODE_INTENT,CHARGE_NODE_HTMLRECEIVED,CHARGE_NODE_XMLRECEIVED,CHARGE_NODE_SERVERERROR,PING_URL + "?action=stop", true, null,cookieData);     
        commThread.run();
        updateTimerReset();
        break;
      
        
      /************** Messages from the Comm thread: ****************************/        
      case CHARGE_NODE_HTMLRECEIVED:
        serverPage = new String(stringData);
        dashMessages.sendData( UIActivity.UI_INTENT_IN, IDashMessages.CHARGE_NODE_ID, null, serverPage, getChargeData(STATUS_CONNECTED,0.0f,0.0f) );
        watchdogCounter = 0;
        break;
        
      case CHARGE_NODE_XMLRECEIVED:
        String chargeStatus = "";
        String pageHTML = "";
        float chargeCurrent = 0f;
        float chargeUnits = 0f;
        if (data != null)
          {
          if (data.containsKey("ChargeStatus")) chargeStatus  = data.getString("ChargeStatus");
          if (data.containsKey("Current"))      chargeCurrent = data.getFloat("Current", 0.0f);
          if (data.containsKey("Units"))        chargeUnits   = data.getFloat("Units", 0.0f);
          if (data.containsKey("PageData"))     pageHTML      = data.getString("PageData");
          }
        if (chargeStatus.equals("CHARGING"))  status = STATUS_CHARGING;
        else                                  status = STATUS_CONNECTED;
        dashMessages.sendData( UIActivity.UI_INTENT_IN, IDashMessages.CHARGE_NODE_ID, null, pageHTML, getChargeData(status,chargeCurrent,chargeUnits) );
        watchdogCounter = 0;
        break;
      
      case CHARGE_NODE_SERVERERROR:
        status = STATUS_DISCONNECTED;
        dashMessages.sendData( UIActivity.UI_INTENT_IN, IDashMessages.CHARGE_NODE_ID, null, stringData, getChargeData(STATUS_DISCONNECTED,0.0f,0.0f) );      
        break;
      
      }
    }
    
  
    
  
  private void updateTimerReset()
    {
    updateTimer.removeCallbacks(updateTimerTask);                // ...Make sure there is no active callback already....
    updateTimer.postDelayed(updateTimerTask, READ_EVERY);        // ...Callback in n milliseconds!
    }
  
  
  
  /*********** Update Timer: *************************************************************************************/
  private Runnable updateTimerTask = new Runnable() 
   {
   // Creates a Runnable which will be called after a delay, to carry out a read of vehicle data. 
   public void run()  
     {
     updateTimer.removeCallbacks(updateTimerTask);                // ...Make sure there is no active callback already....
     watchdogCounter++;
     if (watchdogCounter >= WATCHDOG_OVERFLOW)
       {
       // TODO: Connection timeout.
       status = STATUS_DISCONNECTED;  // Give up. 
       }
     
     switch (status)
       {
       case STATUS_CONNECTING:
         // We are waiting for a response from the server:
         break;
         
       case STATUS_CONNECTED:
       case STATUS_CHARGING:
         // We are connected / charging: Send ping:
         ChargerHTTPConn commThread = new ChargerHTTPConn(weakContext,CHARGE_NODE_INTENT,CHARGE_NODE_HTMLRECEIVED,CHARGE_NODE_XMLRECEIVED,CHARGE_NODE_SERVERERROR,PING_URL, true, null,cookieData);        // Start the Comm thread, and give it the URL of the server. 
         commThread.run();
         break;
         
       default: 
       }
     updateTimer.postDelayed(updateTimerTask, READ_EVERY);        // ...Callback in n milliseconds!
     } 
   };
   /***************************************************************************************************************/
  
  
  
  
  
  /*********** Connect Method: ************************
   * Establish a connection: 
   ****************************************************/
  private void connect()
    {
    
    }
  
  
  
  /******** Suspend and Resume: ************************
   * Suspend should be called when the UI is paused, to 
   * stop any actions in progress. 
   * Resume should be called when the UI is reloaded. 
   ****************************************************/
  public void suspend()
    {
    // TODO: Implement.
    updateTimer.removeCallbacks(updateTimerTask);                // ...Make sure there is no active callback already....
    }
  
  public void resume()
    {
    updateTimerReset();    
    }
  
  
  
 
  
  private Bundle getChargeData(int status, float current, float ah)
    {
    Bundle chargeData = new Bundle();
    chargeData.putFloat( CHARGE_STATUS,  status  );
    chargeData.putFloat( CHARGE_CURRENT, current );
    chargeData.putFloat( CHARGE_AH,      ah      );
    return chargeData;
    }
  
  
  
  
  
  
  
  
  
    
    
  
  }  // [class]
