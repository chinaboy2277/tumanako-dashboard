package com.tumanako.dash;

/************************************************************************************
Tumanako - Electric Vehicle and Motor control software

Copyright (C) 2012 Jeremy Cole-Baker <jeremy@rhtech.co.nz>

This file is part of Tumanako Dashboard.

Tumanako is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Tumanako is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Tumanako.  If not, see <http://www.gnu.org/licenses/>.

*************************************************************************************/

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import android.content.Context;
import android.os.Bundle;

import org.apache.commons.lang3.StringEscapeUtils;



/***********************************************************************************************
 * HTTP Connection Class: 
 * 
 * This class handles an HTTP connection to a server, using a new thread. 
 * 
 * @author Jeremy Cole-Baker / Riverhead Technology
 *
 **********************************************************************************************/


public class ChargerHTTPConn extends Thread implements IDashMessages
  {

  public static final String HTTPCONN_INTENT_IN  = "com.tumanako.dash.httpconnection";   // An Intent with this Action is generated by the UI to send messages to this class.  
  
  private final String connectTo;
  private final Bundle postData;
  private final Bundle cookieDataToSend;
  
  private final String responseIntent; 
  private final int messageIDHTML;
  private final int messageIDXML;
  private final int messageIDError;
  private DashMessages comthreadMessages;  // We'll need to generate intents so we can interract with the rest of the app.  

  private final boolean expectXML; 
  
  
  
  
  
  /************** Thread Constructor: **************************************************/
  public ChargerHTTPConn(WeakReference<Context> weakContext, 
                        String thisResponseIntent,
                        int thisHTMLMessageID,
                        int thisXMLMessageID,
                        int thisErrorMessageID,
                        String thisConnectTo, 
                        boolean thisExpectXML, 
                        Bundle thisPostData, 
                        Bundle thisCookieData) 
    {
    // Save the specified connectTo URL and bundle of POST data. 
    // These will be used when the thread is launched. 
    connectTo = thisConnectTo;
    expectXML = thisExpectXML;
    if (thisPostData != null) postData = new Bundle( thisPostData );
    else                      postData = null;
    if (thisCookieData != null) cookieDataToSend = new Bundle( thisCookieData );
    else                        cookieDataToSend = null;
    responseIntent = thisResponseIntent;
    messageIDHTML  = thisHTMLMessageID;
    messageIDXML   = thisXMLMessageID;
    messageIDError = thisErrorMessageID;
    comthreadMessages = new DashMessages((Context)weakContext.get(),this,HTTPCONN_INTENT_IN);
    }

  
  
  
  
  /******************* Private Methods **************************************************/
  
  
  
  
  /********* XML Parser: **********************************
   * Parses an XML stream from the server and converts to name/value pairs. 
   * @param xmlStream - InputStream representing a connection to a server, from which we expect to receive an XML document. 
   * @return Bundle containing the text from the elements in the XML, as name/value pairs. 
   ********************************************************/
  private Bundle parseXML(InputStream xmlStream)
    {
    Bundle thisResult = new Bundle();
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); // A document builder factory to create new XML document structures.   
    try
      {
      DocumentBuilder xmlDocBuilder = dbf.newDocumentBuilder();  // Use the factory to create a new document builder. 
      xmlDocBuilder.reset();
      Document xml = xmlDocBuilder.parse(xmlStream);             // Parse the incomming XML data. 
      Element rootElement = xml.getDocumentElement();            // Get the XML root element.
      getTagString(thisResult,rootElement,"ChargeStatus");      // Extract each XML tag and store in our result bundle. 
      getTagFloat(thisResult,rootElement,"Price");
      getTagFloat(thisResult,rootElement,"Current");
      getTagFloat(thisResult,rootElement,"Units");
      getTagFloat(thisResult,rootElement,"TotalCost");
      getTagString(thisResult,rootElement,"ChargeTime");
      getTagHTML(thisResult,rootElement,"PageData");
      }
    catch (ParserConfigurationException pce)  {  pce.printStackTrace();  }  //
    catch (SAXException se)                   {  se.printStackTrace();   }  //  Catch any errors. 
    catch (IOException ioe)                   {  ioe.printStackTrace();  }  //
    catch (Exception     e)                   {  e.printStackTrace();    }  //
    return thisResult;  // Return the bundle of results!
    }
  /***********************************************************************************/  
  private String getTagData(Element parentElement, String tag)
    {
    // Get the contents of a specific XML tag (as a string): 
    NodeList nodes = parentElement.getElementsByTagName(tag);
    if(nodes != null && nodes.getLength() > 0) 
      {
      Element thisElement = (Element)nodes.item(0);
      return thisElement.getFirstChild().getNodeValue();
      }
    else
      {  return null;  }
    }
  /***********************************************************************************/
  private void getTagString(Bundle dataBundle, Element parentElement, String tag)
    {
    // Add a string from an XML tag content to a bundle of data: 
    String tagData = getTagData(parentElement,tag);
    if (tagData != null)  dataBundle.putString( tag, tagData );
    }
  /***********************************************************************************/
  private void getTagHTML(Bundle dataBundle, Element parentElement, String tag)
    {
    // Add a string containing encoded HTML from an XML tag content to a bundle of data: 
    String tagData = getTagData(parentElement,tag);
    if (tagData != null)  
      {
      String encHTML = tagData.replace("~", "&");
      String rawHTML = StringEscapeUtils.unescapeHtml4(encHTML);
      dataBundle.putString( tag, rawHTML );
      }
    }
  /***********************************************************************************/  
  private void getTagFloat(Bundle dataBundle, Element parentElement, String tag)
    {
    // Add a float value from an XML tag content to a bundle of data:    
    String tagData = getTagData(parentElement,tag);
    if (tagData != null)  
      {
      try
        {
        dataBundle.putFloat(tag, Float.parseFloat(tagData) );
        }
      catch (Exception e)
        { }
      }
    }
  /***********************************************************************************/
  
  
  
  /********** Extract Cookies: **********************************************
   * This method extracts cookie requests from the server (sent in the HTTP headers)
   **************************************************************************/
  private Bundle getCookies(HttpURLConnection serverConn)
    {
    Bundle cookies = new Bundle();
    Map<String, List<String>> httpHeaders = serverConn.getHeaderFields();
    Set<String> headerKeys = httpHeaders.keySet();
    for (String headerKey : headerKeys)
      {
      // --DEBUG!-- Log.i(com.tumanako.ui.UIActivity.APP_TAG, " CommThread -> Header: " + headerKey + "=" + serverConn.getHeaderField(headerKey) );      
      if (headerKey.equals("Set-Cookie")) 
        {                  
        String cookie = serverConn.getHeaderField(headerKey);
        cookie = cookie.substring(0, cookie.indexOf(";"));
        String cookieName = cookie.substring(0, cookie.indexOf("="));
        String cookieValue = cookie.substring(cookie.indexOf("=") + 1, cookie.length());
        cookies.putString(cookieName, cookieValue);
        // --DEBUG!-- Log.i(com.tumanako.ui.UIActivity.APP_TAG, " CommThread -> Set-Cookie: " + cookieName + "=" + cookieValue );           
        }
      }
    return cookies;
    }
  
  
  
  /********************* Encode Cookies: ******************************************
   * This method encodes cookie data that we wish to send back to the server. 
   * @param data Bundle of cookie data we wish to send in the request (name/value pairs)
   * @return String containing encoded cookie data: e.g. "name1=value1; name2=value2", etc. 
   ********************************************************************************/
   private String buildCookies(Bundle data)
     {
     if (data == null)
       { return "";  }
     else
       {
       Set<String> keys = data.keySet();                 // Get a list of data keys in the bundle of submitted data. 
       Iterator<String> myIterator = keys.iterator();    // This is an iterator to iterate over the list.
       String key;
       String value;
       StringBuffer cookieStrings = new StringBuffer("");
       while (myIterator.hasNext())
         {
         key = myIterator.next();
         value = data.get(key).toString();
         cookieStrings.append(key);
         cookieStrings.append("=");
         cookieStrings.append(URLEncoder.encode(value));
         if (myIterator.hasNext()) cookieStrings.append("; ");
         }
       // --DEBUG!-- Log.i(com.tumanako.ui.UIActivity.APP_TAG, " CommThread -> Cookies: " +  cookieStrings.toString());       
       return cookieStrings.toString();
       }
     }
  
  
  
   
  /***************** Make POST Data: **********************************************
  * Turn a bundle of key/value pairs into a string of POST data suitable for 
  * use in the HTTP POST request:
  *********************************************************************************/ 
  private String encodePostData(Bundle data)
    {
    Set<String> keys = data.keySet();                 // Get a list of data keys in the bundle of submitted data. 
    Iterator<String> myIterator = keys.iterator();    // This is an iterator to iterate over the list.
    String key;
    String value;
    StringBuffer postData = new StringBuffer("");
    while (myIterator.hasNext())
      {
      key = myIterator.next();
      value = data.get(key).toString();
      postData.append(key);
      postData.append("=");
      postData.append(URLEncoder.encode(value));
      if (myIterator.hasNext()) postData.append("&");
      }
    return postData.toString();
    }

  
  
  
  
  
  
  /*************************************************************************************
   ******** RUN THREAD: ****************************************************************
   *************************************************************************************/
  public void run()
    {
    int readChr = 1;
    URL serverURL;
    final String useCharset = "UTF-8"; 

    // if there is data to send to the server, encode it: 
    String postString = "";
    if (postData != null) postString = encodePostData(postData);
    
    // Get output data size: 
    int postDataSize = postString.length();    
    
    try 
      {
      // Attempt to connect to the server:
      serverURL = new URL(connectTo);
      HttpURLConnection serverConn = (HttpURLConnection) serverURL.openConnection();
      serverConn.setRequestProperty("Cookie", buildCookies(cookieDataToSend) );

      if (postDataSize > 0)
        {
        // We have data to send: 
        serverConn.setRequestMethod("POST"); 
        serverConn.setDoOutput(true);
        serverConn.setRequestProperty("Accept-Charset", useCharset); 
        serverConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded;charset=" + useCharset);
        OutputStream streamOut = serverConn.getOutputStream(); 
        streamOut.write(postString.getBytes(useCharset));
        streamOut.close();
        }
      else
        {  serverConn.connect();  }
      
      // See if the server sent any cookies: 
      Bundle requestCookies = getCookies(serverConn);
      
      // Create input stream and read the response sent by the server: 
      Bundle dataBundle;
      StringBuffer htmlData = null;
      InputStream streamIn = new BufferedInputStream(serverConn.getInputStream());
      if (expectXML)
        {
        // We're expecting an XML result, so pass the input stream to the XML parser:
        dataBundle = parseXML(streamIn);
        }
      else  // [if (expectXML)]
        {
        // We're expecting an HTML or other response. Read data that the server sent to us (HTTP Response):
        htmlData = new StringBuffer("");
        dataBundle = new Bundle();         // Empty data bundle. We'll add any cookie data to this. 
        while (readChr > -1)
          {
          //if (this.isCancelled()) return 0;
          readChr = streamIn.read();
          if (readChr > -1) htmlData.append((char)readChr);
          }
        }  // [if (expectXML)]
      
      //if (this.isCancelled()) return 0;
      
      streamIn.close();
      serverConn.disconnect();
      // Add any cookies from the request to any XML data we have: 
      dataBundle.putBundle("Cookies", requestCookies);
      // Done! Hopefully we got some data back!
      if (expectXML) comthreadMessages.sendData(responseIntent, messageIDXML,  null, null, dataBundle);
      else           comthreadMessages.sendData(responseIntent, messageIDHTML, null, htmlData.toString(), dataBundle);
      }
    
    catch (Exception e)
      {
      e.printStackTrace();
      comthreadMessages.sendData(responseIntent, messageIDError, null, e.getMessage() , null);
      }
    
    }  // [run()]

    
  
  // ******** Cleanup: Called when the thread is terminated. **************
  public void cancel()
    {
    // *** Stop the network operation... ***
    }



 public void messageReceived(String action, int message, Float floatData, String stringData, Bundle data)
   {
   // TODO Auto-generated method stub
   } 


  }
